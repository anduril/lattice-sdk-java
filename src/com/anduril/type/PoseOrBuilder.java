// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: anduril/type/coords.pub.proto

package com.anduril.type;

public interface PoseOrBuilder extends
    // @@protoc_insertion_point(interface_extends:anduril.type.Pose)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Geospatial location defined by this Pose.
   * </pre>
   *
   * <code>.anduril.type.LLA pos = 1 [json_name = "pos"];</code>
   * @return Whether the pos field is set.
   */
  boolean hasPos();
  /**
   * <pre>
   * Geospatial location defined by this Pose.
   * </pre>
   *
   * <code>.anduril.type.LLA pos = 1 [json_name = "pos"];</code>
   * @return The pos.
   */
  com.anduril.type.LLA getPos();
  /**
   * <pre>
   * Geospatial location defined by this Pose.
   * </pre>
   *
   * <code>.anduril.type.LLA pos = 1 [json_name = "pos"];</code>
   */
  com.anduril.type.LLAOrBuilder getPosOrBuilder();

  /**
   * <pre>
   * The quaternion to transform a point in the Pose frame to the ENU frame. The Pose frame could be Body, Turret,
   * etc and is determined by the context in which this Pose is used.
   * The normal convention for defining orientation is to list the frames of transformation, for example
   * att_gimbal_to_enu is the quaternion which transforms a point in the gimbal frame to the body frame, but
   * in this case we truncate to att_enu because the Pose frame isn't defined. A potentially better name for this
   * field would have been att_pose_to_enu.
   *
   * Implementations of this quaternion should left multiply this quaternion to transform a point from the Pose frame
   * to the enu frame. Following the geometry-cpp rotation convention, the following example would be valid:
   * (https://ghe.anduril.dev/autonomy/geometry-cpp/blob/master/src/Rotation.h#L90)
   *
   * Point&lt;Pose&#92;&gt; posePt{1,0,0};
   * Rotation&lt;Enu, Pose&#92;&gt; attPoseToEnu{};
   * Point&lt;Enu&#92;&gt; = attPoseToEnu*posePt;
   *
   * This transformed point represents some vector in ENU space that is aligned with the x axis of the attPoseToEnu
   * matrix.
   *
   * An alternative matrix expression is as follows:
   * ptEnu = M x ptPose
   * </pre>
   *
   * <code>.anduril.type.Quaternion att_enu = 2 [json_name = "attEnu"];</code>
   * @return Whether the attEnu field is set.
   */
  boolean hasAttEnu();
  /**
   * <pre>
   * The quaternion to transform a point in the Pose frame to the ENU frame. The Pose frame could be Body, Turret,
   * etc and is determined by the context in which this Pose is used.
   * The normal convention for defining orientation is to list the frames of transformation, for example
   * att_gimbal_to_enu is the quaternion which transforms a point in the gimbal frame to the body frame, but
   * in this case we truncate to att_enu because the Pose frame isn't defined. A potentially better name for this
   * field would have been att_pose_to_enu.
   *
   * Implementations of this quaternion should left multiply this quaternion to transform a point from the Pose frame
   * to the enu frame. Following the geometry-cpp rotation convention, the following example would be valid:
   * (https://ghe.anduril.dev/autonomy/geometry-cpp/blob/master/src/Rotation.h#L90)
   *
   * Point&lt;Pose&#92;&gt; posePt{1,0,0};
   * Rotation&lt;Enu, Pose&#92;&gt; attPoseToEnu{};
   * Point&lt;Enu&#92;&gt; = attPoseToEnu*posePt;
   *
   * This transformed point represents some vector in ENU space that is aligned with the x axis of the attPoseToEnu
   * matrix.
   *
   * An alternative matrix expression is as follows:
   * ptEnu = M x ptPose
   * </pre>
   *
   * <code>.anduril.type.Quaternion att_enu = 2 [json_name = "attEnu"];</code>
   * @return The attEnu.
   */
  com.anduril.type.Quaternion getAttEnu();
  /**
   * <pre>
   * The quaternion to transform a point in the Pose frame to the ENU frame. The Pose frame could be Body, Turret,
   * etc and is determined by the context in which this Pose is used.
   * The normal convention for defining orientation is to list the frames of transformation, for example
   * att_gimbal_to_enu is the quaternion which transforms a point in the gimbal frame to the body frame, but
   * in this case we truncate to att_enu because the Pose frame isn't defined. A potentially better name for this
   * field would have been att_pose_to_enu.
   *
   * Implementations of this quaternion should left multiply this quaternion to transform a point from the Pose frame
   * to the enu frame. Following the geometry-cpp rotation convention, the following example would be valid:
   * (https://ghe.anduril.dev/autonomy/geometry-cpp/blob/master/src/Rotation.h#L90)
   *
   * Point&lt;Pose&#92;&gt; posePt{1,0,0};
   * Rotation&lt;Enu, Pose&#92;&gt; attPoseToEnu{};
   * Point&lt;Enu&#92;&gt; = attPoseToEnu*posePt;
   *
   * This transformed point represents some vector in ENU space that is aligned with the x axis of the attPoseToEnu
   * matrix.
   *
   * An alternative matrix expression is as follows:
   * ptEnu = M x ptPose
   * </pre>
   *
   * <code>.anduril.type.Quaternion att_enu = 2 [json_name = "attEnu"];</code>
   */
  com.anduril.type.QuaternionOrBuilder getAttEnuOrBuilder();
}
