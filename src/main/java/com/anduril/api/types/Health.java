/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.anduril.api.types;

import com.anduril.api.core.ObjectMappers;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = Health.Builder.class)
public final class Health {
    private final Optional<HealthConnectionStatus> connectionStatus;

    private final Optional<HealthHealthStatus> healthStatus;

    private final Optional<List<ComponentHealth>> components;

    private final Optional<OffsetDateTime> updateTime;

    private final Optional<List<Alert>> activeAlerts;

    private final Map<String, Object> additionalProperties;

    private Health(
            Optional<HealthConnectionStatus> connectionStatus,
            Optional<HealthHealthStatus> healthStatus,
            Optional<List<ComponentHealth>> components,
            Optional<OffsetDateTime> updateTime,
            Optional<List<Alert>> activeAlerts,
            Map<String, Object> additionalProperties) {
        this.connectionStatus = connectionStatus;
        this.healthStatus = healthStatus;
        this.components = components;
        this.updateTime = updateTime;
        this.activeAlerts = activeAlerts;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return Status indicating whether the entity is able to communicate with Entity Manager.
     */
    @JsonProperty("connectionStatus")
    public Optional<HealthConnectionStatus> getConnectionStatus() {
        return connectionStatus;
    }

    /**
     * @return Top-level health status; typically a roll-up of individual component healths.
     */
    @JsonProperty("healthStatus")
    public Optional<HealthHealthStatus> getHealthStatus() {
        return healthStatus;
    }

    /**
     * @return Health of individual components running on this Entity.
     */
    @JsonProperty("components")
    public Optional<List<ComponentHealth>> getComponents() {
        return components;
    }

    /**
     * @return The update time for the top-level health information.
     * If this timestamp is unset, the data is assumed to be most recent
     */
    @JsonProperty("updateTime")
    public Optional<OffsetDateTime> getUpdateTime() {
        return updateTime;
    }

    /**
     * @return Active alerts indicate a critical change in system state sent by the asset
     * that must be made known to an operator or consumer of the common operating picture.
     * Alerts are different from ComponentHealth messages--an active alert does not necessarily
     * indicate a component is in an unhealthy state. For example, an asset may trigger
     * an active alert based on fuel levels running low. Alerts should be removed from this list when their conditions
     * are cleared. In other words, only active alerts should be reported here.
     */
    @JsonProperty("activeAlerts")
    public Optional<List<Alert>> getActiveAlerts() {
        return activeAlerts;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof Health && equalTo((Health) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(Health other) {
        return connectionStatus.equals(other.connectionStatus)
                && healthStatus.equals(other.healthStatus)
                && components.equals(other.components)
                && updateTime.equals(other.updateTime)
                && activeAlerts.equals(other.activeAlerts);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.connectionStatus, this.healthStatus, this.components, this.updateTime, this.activeAlerts);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<HealthConnectionStatus> connectionStatus = Optional.empty();

        private Optional<HealthHealthStatus> healthStatus = Optional.empty();

        private Optional<List<ComponentHealth>> components = Optional.empty();

        private Optional<OffsetDateTime> updateTime = Optional.empty();

        private Optional<List<Alert>> activeAlerts = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(Health other) {
            connectionStatus(other.getConnectionStatus());
            healthStatus(other.getHealthStatus());
            components(other.getComponents());
            updateTime(other.getUpdateTime());
            activeAlerts(other.getActiveAlerts());
            return this;
        }

        /**
         * <p>Status indicating whether the entity is able to communicate with Entity Manager.</p>
         */
        @JsonSetter(value = "connectionStatus", nulls = Nulls.SKIP)
        public Builder connectionStatus(Optional<HealthConnectionStatus> connectionStatus) {
            this.connectionStatus = connectionStatus;
            return this;
        }

        public Builder connectionStatus(HealthConnectionStatus connectionStatus) {
            this.connectionStatus = Optional.ofNullable(connectionStatus);
            return this;
        }

        /**
         * <p>Top-level health status; typically a roll-up of individual component healths.</p>
         */
        @JsonSetter(value = "healthStatus", nulls = Nulls.SKIP)
        public Builder healthStatus(Optional<HealthHealthStatus> healthStatus) {
            this.healthStatus = healthStatus;
            return this;
        }

        public Builder healthStatus(HealthHealthStatus healthStatus) {
            this.healthStatus = Optional.ofNullable(healthStatus);
            return this;
        }

        /**
         * <p>Health of individual components running on this Entity.</p>
         */
        @JsonSetter(value = "components", nulls = Nulls.SKIP)
        public Builder components(Optional<List<ComponentHealth>> components) {
            this.components = components;
            return this;
        }

        public Builder components(List<ComponentHealth> components) {
            this.components = Optional.ofNullable(components);
            return this;
        }

        /**
         * <p>The update time for the top-level health information.
         * If this timestamp is unset, the data is assumed to be most recent</p>
         */
        @JsonSetter(value = "updateTime", nulls = Nulls.SKIP)
        public Builder updateTime(Optional<OffsetDateTime> updateTime) {
            this.updateTime = updateTime;
            return this;
        }

        public Builder updateTime(OffsetDateTime updateTime) {
            this.updateTime = Optional.ofNullable(updateTime);
            return this;
        }

        /**
         * <p>Active alerts indicate a critical change in system state sent by the asset
         * that must be made known to an operator or consumer of the common operating picture.
         * Alerts are different from ComponentHealth messages--an active alert does not necessarily
         * indicate a component is in an unhealthy state. For example, an asset may trigger
         * an active alert based on fuel levels running low. Alerts should be removed from this list when their conditions
         * are cleared. In other words, only active alerts should be reported here.</p>
         */
        @JsonSetter(value = "activeAlerts", nulls = Nulls.SKIP)
        public Builder activeAlerts(Optional<List<Alert>> activeAlerts) {
            this.activeAlerts = activeAlerts;
            return this;
        }

        public Builder activeAlerts(List<Alert> activeAlerts) {
            this.activeAlerts = Optional.ofNullable(activeAlerts);
            return this;
        }

        public Health build() {
            return new Health(
                    connectionStatus, healthStatus, components, updateTime, activeAlerts, additionalProperties);
        }
    }
}
