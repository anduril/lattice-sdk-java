/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.anduril.api.types;

import com.anduril.api.core.ObjectMappers;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = ProjectedFrustum.Builder.class)
public final class ProjectedFrustum {
    private final Optional<Position> upperLeft;

    private final Optional<Position> upperRight;

    private final Optional<Position> bottomRight;

    private final Optional<Position> bottomLeft;

    private final Map<String, Object> additionalProperties;

    private ProjectedFrustum(
            Optional<Position> upperLeft,
            Optional<Position> upperRight,
            Optional<Position> bottomRight,
            Optional<Position> bottomLeft,
            Map<String, Object> additionalProperties) {
        this.upperLeft = upperLeft;
        this.upperRight = upperRight;
        this.bottomRight = bottomRight;
        this.bottomLeft = bottomLeft;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return Upper left point of the frustum.
     */
    @JsonProperty("upperLeft")
    public Optional<Position> getUpperLeft() {
        return upperLeft;
    }

    /**
     * @return Upper right point of the frustum.
     */
    @JsonProperty("upperRight")
    public Optional<Position> getUpperRight() {
        return upperRight;
    }

    /**
     * @return Bottom right point of the frustum.
     */
    @JsonProperty("bottomRight")
    public Optional<Position> getBottomRight() {
        return bottomRight;
    }

    /**
     * @return Bottom left point of the frustum.
     */
    @JsonProperty("bottomLeft")
    public Optional<Position> getBottomLeft() {
        return bottomLeft;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof ProjectedFrustum && equalTo((ProjectedFrustum) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(ProjectedFrustum other) {
        return upperLeft.equals(other.upperLeft)
                && upperRight.equals(other.upperRight)
                && bottomRight.equals(other.bottomRight)
                && bottomLeft.equals(other.bottomLeft);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(this.upperLeft, this.upperRight, this.bottomRight, this.bottomLeft);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<Position> upperLeft = Optional.empty();

        private Optional<Position> upperRight = Optional.empty();

        private Optional<Position> bottomRight = Optional.empty();

        private Optional<Position> bottomLeft = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(ProjectedFrustum other) {
            upperLeft(other.getUpperLeft());
            upperRight(other.getUpperRight());
            bottomRight(other.getBottomRight());
            bottomLeft(other.getBottomLeft());
            return this;
        }

        /**
         * <p>Upper left point of the frustum.</p>
         */
        @JsonSetter(value = "upperLeft", nulls = Nulls.SKIP)
        public Builder upperLeft(Optional<Position> upperLeft) {
            this.upperLeft = upperLeft;
            return this;
        }

        public Builder upperLeft(Position upperLeft) {
            this.upperLeft = Optional.ofNullable(upperLeft);
            return this;
        }

        /**
         * <p>Upper right point of the frustum.</p>
         */
        @JsonSetter(value = "upperRight", nulls = Nulls.SKIP)
        public Builder upperRight(Optional<Position> upperRight) {
            this.upperRight = upperRight;
            return this;
        }

        public Builder upperRight(Position upperRight) {
            this.upperRight = Optional.ofNullable(upperRight);
            return this;
        }

        /**
         * <p>Bottom right point of the frustum.</p>
         */
        @JsonSetter(value = "bottomRight", nulls = Nulls.SKIP)
        public Builder bottomRight(Optional<Position> bottomRight) {
            this.bottomRight = bottomRight;
            return this;
        }

        public Builder bottomRight(Position bottomRight) {
            this.bottomRight = Optional.ofNullable(bottomRight);
            return this;
        }

        /**
         * <p>Bottom left point of the frustum.</p>
         */
        @JsonSetter(value = "bottomLeft", nulls = Nulls.SKIP)
        public Builder bottomLeft(Optional<Position> bottomLeft) {
            this.bottomLeft = bottomLeft;
            return this;
        }

        public Builder bottomLeft(Position bottomLeft) {
            this.bottomLeft = Optional.ofNullable(bottomLeft);
            return this;
        }

        public ProjectedFrustum build() {
            return new ProjectedFrustum(upperLeft, upperRight, bottomRight, bottomLeft, additionalProperties);
        }
    }
}
