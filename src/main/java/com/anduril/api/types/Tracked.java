/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.anduril.api.types;

import com.anduril.api.core.ObjectMappers;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = Tracked.Builder.class)
public final class Tracked {
    private final Optional<Integer> trackQualityWrapper;

    private final Optional<Integer> sensorHits;

    private final Optional<UInt32Range> numberOfObjects;

    private final Optional<Double> radarCrossSection;

    private final Optional<OffsetDateTime> lastMeasurementTime;

    private final Optional<LineOfBearing> lineOfBearing;

    private final Map<String, Object> additionalProperties;

    private Tracked(
            Optional<Integer> trackQualityWrapper,
            Optional<Integer> sensorHits,
            Optional<UInt32Range> numberOfObjects,
            Optional<Double> radarCrossSection,
            Optional<OffsetDateTime> lastMeasurementTime,
            Optional<LineOfBearing> lineOfBearing,
            Map<String, Object> additionalProperties) {
        this.trackQualityWrapper = trackQualityWrapper;
        this.sensorHits = sensorHits;
        this.numberOfObjects = numberOfObjects;
        this.radarCrossSection = radarCrossSection;
        this.lastMeasurementTime = lastMeasurementTime;
        this.lineOfBearing = lineOfBearing;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return Quality score, 0-15, nil if none
     */
    @JsonProperty("trackQualityWrapper")
    public Optional<Integer> getTrackQualityWrapper() {
        return trackQualityWrapper;
    }

    /**
     * @return Sensor hits aggregation on the tracked entity.
     */
    @JsonProperty("sensorHits")
    public Optional<Integer> getSensorHits() {
        return sensorHits;
    }

    /**
     * @return Estimated number of objects or units that are represented by this entity. Known as Strength in certain contexts (Link16)
     * if UpperBound == LowerBound; (strength = LowerBound)
     * If both UpperBound and LowerBound are defined; strength is between LowerBound and UpperBound (represented as string &quot;Strength: 4-5&quot;)
     * If UpperBound is defined only (LowerBound unset), Strength ≤ UpperBound
     * If LowerBound is defined only (UpperBound unset), LowerBound ≤ Strength
     * 0 indicates unset.
     */
    @JsonProperty("numberOfObjects")
    public Optional<UInt32Range> getNumberOfObjects() {
        return numberOfObjects;
    }

    /**
     * @return The radar cross section (RCS) is a measure of how detectable an object is by radar. A large RCS indicates an object is more easily
     * detected. The unit is “decibels per square meter,” or dBsm
     */
    @JsonProperty("radarCrossSection")
    public Optional<Double> getRadarCrossSection() {
        return radarCrossSection;
    }

    /**
     * @return Timestamp of the latest tracking measurement for this entity.
     */
    @JsonProperty("lastMeasurementTime")
    public Optional<OffsetDateTime> getLastMeasurementTime() {
        return lastMeasurementTime;
    }

    /**
     * @return The relative position of a track with respect to the entity that is tracking it. Used for tracks that do not yet have a 3D position.
     * For this entity (A), being tracked by some entity (B), this LineOfBearing would express a ray from B to A.
     */
    @JsonProperty("lineOfBearing")
    public Optional<LineOfBearing> getLineOfBearing() {
        return lineOfBearing;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof Tracked && equalTo((Tracked) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(Tracked other) {
        return trackQualityWrapper.equals(other.trackQualityWrapper)
                && sensorHits.equals(other.sensorHits)
                && numberOfObjects.equals(other.numberOfObjects)
                && radarCrossSection.equals(other.radarCrossSection)
                && lastMeasurementTime.equals(other.lastMeasurementTime)
                && lineOfBearing.equals(other.lineOfBearing);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.trackQualityWrapper,
                this.sensorHits,
                this.numberOfObjects,
                this.radarCrossSection,
                this.lastMeasurementTime,
                this.lineOfBearing);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<Integer> trackQualityWrapper = Optional.empty();

        private Optional<Integer> sensorHits = Optional.empty();

        private Optional<UInt32Range> numberOfObjects = Optional.empty();

        private Optional<Double> radarCrossSection = Optional.empty();

        private Optional<OffsetDateTime> lastMeasurementTime = Optional.empty();

        private Optional<LineOfBearing> lineOfBearing = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(Tracked other) {
            trackQualityWrapper(other.getTrackQualityWrapper());
            sensorHits(other.getSensorHits());
            numberOfObjects(other.getNumberOfObjects());
            radarCrossSection(other.getRadarCrossSection());
            lastMeasurementTime(other.getLastMeasurementTime());
            lineOfBearing(other.getLineOfBearing());
            return this;
        }

        /**
         * <p>Quality score, 0-15, nil if none</p>
         */
        @JsonSetter(value = "trackQualityWrapper", nulls = Nulls.SKIP)
        public Builder trackQualityWrapper(Optional<Integer> trackQualityWrapper) {
            this.trackQualityWrapper = trackQualityWrapper;
            return this;
        }

        public Builder trackQualityWrapper(Integer trackQualityWrapper) {
            this.trackQualityWrapper = Optional.ofNullable(trackQualityWrapper);
            return this;
        }

        /**
         * <p>Sensor hits aggregation on the tracked entity.</p>
         */
        @JsonSetter(value = "sensorHits", nulls = Nulls.SKIP)
        public Builder sensorHits(Optional<Integer> sensorHits) {
            this.sensorHits = sensorHits;
            return this;
        }

        public Builder sensorHits(Integer sensorHits) {
            this.sensorHits = Optional.ofNullable(sensorHits);
            return this;
        }

        /**
         * <p>Estimated number of objects or units that are represented by this entity. Known as Strength in certain contexts (Link16)
         * if UpperBound == LowerBound; (strength = LowerBound)
         * If both UpperBound and LowerBound are defined; strength is between LowerBound and UpperBound (represented as string &quot;Strength: 4-5&quot;)
         * If UpperBound is defined only (LowerBound unset), Strength ≤ UpperBound
         * If LowerBound is defined only (UpperBound unset), LowerBound ≤ Strength
         * 0 indicates unset.</p>
         */
        @JsonSetter(value = "numberOfObjects", nulls = Nulls.SKIP)
        public Builder numberOfObjects(Optional<UInt32Range> numberOfObjects) {
            this.numberOfObjects = numberOfObjects;
            return this;
        }

        public Builder numberOfObjects(UInt32Range numberOfObjects) {
            this.numberOfObjects = Optional.ofNullable(numberOfObjects);
            return this;
        }

        /**
         * <p>The radar cross section (RCS) is a measure of how detectable an object is by radar. A large RCS indicates an object is more easily
         * detected. The unit is “decibels per square meter,” or dBsm</p>
         */
        @JsonSetter(value = "radarCrossSection", nulls = Nulls.SKIP)
        public Builder radarCrossSection(Optional<Double> radarCrossSection) {
            this.radarCrossSection = radarCrossSection;
            return this;
        }

        public Builder radarCrossSection(Double radarCrossSection) {
            this.radarCrossSection = Optional.ofNullable(radarCrossSection);
            return this;
        }

        /**
         * <p>Timestamp of the latest tracking measurement for this entity.</p>
         */
        @JsonSetter(value = "lastMeasurementTime", nulls = Nulls.SKIP)
        public Builder lastMeasurementTime(Optional<OffsetDateTime> lastMeasurementTime) {
            this.lastMeasurementTime = lastMeasurementTime;
            return this;
        }

        public Builder lastMeasurementTime(OffsetDateTime lastMeasurementTime) {
            this.lastMeasurementTime = Optional.ofNullable(lastMeasurementTime);
            return this;
        }

        /**
         * <p>The relative position of a track with respect to the entity that is tracking it. Used for tracks that do not yet have a 3D position.
         * For this entity (A), being tracked by some entity (B), this LineOfBearing would express a ray from B to A.</p>
         */
        @JsonSetter(value = "lineOfBearing", nulls = Nulls.SKIP)
        public Builder lineOfBearing(Optional<LineOfBearing> lineOfBearing) {
            this.lineOfBearing = lineOfBearing;
            return this;
        }

        public Builder lineOfBearing(LineOfBearing lineOfBearing) {
            this.lineOfBearing = Optional.ofNullable(lineOfBearing);
            return this;
        }

        public Tracked build() {
            return new Tracked(
                    trackQualityWrapper,
                    sensorHits,
                    numberOfObjects,
                    radarCrossSection,
                    lastMeasurementTime,
                    lineOfBearing,
                    additionalProperties);
        }
    }
}
