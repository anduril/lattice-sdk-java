/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.anduril.types;

import com.anduril.core.ObjectMappers;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = LocationUncertainty.Builder.class)
public final class LocationUncertainty {
    private final Optional<TMat3> positionEnuCov;

    private final Optional<TMat3> velocityEnuCov;

    private final Optional<ErrorEllipse> positionErrorEllipse;

    private final Map<String, Object> additionalProperties;

    private LocationUncertainty(
            Optional<TMat3> positionEnuCov,
            Optional<TMat3> velocityEnuCov,
            Optional<ErrorEllipse> positionErrorEllipse,
            Map<String, Object> additionalProperties) {
        this.positionEnuCov = positionEnuCov;
        this.velocityEnuCov = velocityEnuCov;
        this.positionErrorEllipse = positionErrorEllipse;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return Positional covariance represented by the upper triangle of the covariance matrix. It is valid to populate
     * only the diagonal of the matrix if the full covariance matrix is unknown.
     */
    @JsonProperty("positionEnuCov")
    public Optional<TMat3> getPositionEnuCov() {
        return positionEnuCov;
    }

    /**
     * @return Velocity covariance represented by the upper triangle of the covariance matrix. It is valid to populate
     * only the diagonal of the matrix if the full covariance matrix is unknown.
     */
    @JsonProperty("velocityEnuCov")
    public Optional<TMat3> getVelocityEnuCov() {
        return velocityEnuCov;
    }

    /**
     * @return An ellipse that describes the certainty probability and error boundary for a given geolocation.
     */
    @JsonProperty("positionErrorEllipse")
    public Optional<ErrorEllipse> getPositionErrorEllipse() {
        return positionErrorEllipse;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof LocationUncertainty && equalTo((LocationUncertainty) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(LocationUncertainty other) {
        return positionEnuCov.equals(other.positionEnuCov)
                && velocityEnuCov.equals(other.velocityEnuCov)
                && positionErrorEllipse.equals(other.positionErrorEllipse);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(this.positionEnuCov, this.velocityEnuCov, this.positionErrorEllipse);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<TMat3> positionEnuCov = Optional.empty();

        private Optional<TMat3> velocityEnuCov = Optional.empty();

        private Optional<ErrorEllipse> positionErrorEllipse = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(LocationUncertainty other) {
            positionEnuCov(other.getPositionEnuCov());
            velocityEnuCov(other.getVelocityEnuCov());
            positionErrorEllipse(other.getPositionErrorEllipse());
            return this;
        }

        /**
         * <p>Positional covariance represented by the upper triangle of the covariance matrix. It is valid to populate
         * only the diagonal of the matrix if the full covariance matrix is unknown.</p>
         */
        @JsonSetter(value = "positionEnuCov", nulls = Nulls.SKIP)
        public Builder positionEnuCov(Optional<TMat3> positionEnuCov) {
            this.positionEnuCov = positionEnuCov;
            return this;
        }

        public Builder positionEnuCov(TMat3 positionEnuCov) {
            this.positionEnuCov = Optional.ofNullable(positionEnuCov);
            return this;
        }

        /**
         * <p>Velocity covariance represented by the upper triangle of the covariance matrix. It is valid to populate
         * only the diagonal of the matrix if the full covariance matrix is unknown.</p>
         */
        @JsonSetter(value = "velocityEnuCov", nulls = Nulls.SKIP)
        public Builder velocityEnuCov(Optional<TMat3> velocityEnuCov) {
            this.velocityEnuCov = velocityEnuCov;
            return this;
        }

        public Builder velocityEnuCov(TMat3 velocityEnuCov) {
            this.velocityEnuCov = Optional.ofNullable(velocityEnuCov);
            return this;
        }

        /**
         * <p>An ellipse that describes the certainty probability and error boundary for a given geolocation.</p>
         */
        @JsonSetter(value = "positionErrorEllipse", nulls = Nulls.SKIP)
        public Builder positionErrorEllipse(Optional<ErrorEllipse> positionErrorEllipse) {
            this.positionErrorEllipse = positionErrorEllipse;
            return this;
        }

        public Builder positionErrorEllipse(ErrorEllipse positionErrorEllipse) {
            this.positionErrorEllipse = Optional.ofNullable(positionErrorEllipse);
            return this;
        }

        public LocationUncertainty build() {
            return new LocationUncertainty(positionEnuCov, velocityEnuCov, positionErrorEllipse, additionalProperties);
        }
    }
}
