/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.anduril.types;

import com.anduril.core.ObjectMappers;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = FieldOfView.Builder.class)
public final class FieldOfView {
    private final Optional<Integer> fovId;

    private final Optional<String> mountId;

    private final Optional<ProjectedFrustum> projectedFrustum;

    private final Optional<Position> projectedCenterRay;

    private final Optional<Pose> centerRayPose;

    private final Optional<Float> horizontalFov;

    private final Optional<Float> verticalFov;

    private final Optional<Float> range;

    private final Optional<FieldOfViewMode> mode;

    private final Map<String, Object> additionalProperties;

    private FieldOfView(
            Optional<Integer> fovId,
            Optional<String> mountId,
            Optional<ProjectedFrustum> projectedFrustum,
            Optional<Position> projectedCenterRay,
            Optional<Pose> centerRayPose,
            Optional<Float> horizontalFov,
            Optional<Float> verticalFov,
            Optional<Float> range,
            Optional<FieldOfViewMode> mode,
            Map<String, Object> additionalProperties) {
        this.fovId = fovId;
        this.mountId = mountId;
        this.projectedFrustum = projectedFrustum;
        this.projectedCenterRay = projectedCenterRay;
        this.centerRayPose = centerRayPose;
        this.horizontalFov = horizontalFov;
        this.verticalFov = verticalFov;
        this.range = range;
        this.mode = mode;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return The Id for one instance of a FieldOfView, persisted across multiple updates to provide continuity during
     * smoothing. This is relevant for sensors where the dwell schedule is on the order of
     * milliseconds, making multiple FOVs a requirement for proper display of search beams.
     */
    @JsonProperty("fovId")
    public Optional<Integer> getFovId() {
        return fovId;
    }

    /**
     * @return The Id of the mount the sensor is on.
     */
    @JsonProperty("mountId")
    public Optional<String> getMountId() {
        return mountId;
    }

    /**
     * @return The field of view the sensor projected onto the ground.
     */
    @JsonProperty("projectedFrustum")
    public Optional<ProjectedFrustum> getProjectedFrustum() {
        return projectedFrustum;
    }

    /**
     * @return Center ray of the frustum projected onto the ground.
     */
    @JsonProperty("projectedCenterRay")
    public Optional<Position> getProjectedCenterRay() {
        return projectedCenterRay;
    }

    /**
     * @return The origin and direction of the center ray for this sensor relative to the ENU frame. A ray which is aligned with
     * the positive X axis in the sensor frame will be transformed into the ray along the sensor direction in the ENU
     * frame when transformed by the quaternion contained in this pose.
     */
    @JsonProperty("centerRayPose")
    public Optional<Pose> getCenterRayPose() {
        return centerRayPose;
    }

    /**
     * @return Horizontal field of view in radians.
     */
    @JsonProperty("horizontalFov")
    public Optional<Float> getHorizontalFov() {
        return horizontalFov;
    }

    /**
     * @return Vertical field of view in radians.
     */
    @JsonProperty("verticalFov")
    public Optional<Float> getVerticalFov() {
        return verticalFov;
    }

    /**
     * @return Sensor range in meters.
     */
    @JsonProperty("range")
    public Optional<Float> getRange() {
        return range;
    }

    /**
     * @return The mode that this sensor is currently in, used to display for context in the UI. Some sensors can emit multiple
     * sensor field of views with different modes, for example a radar can simultaneously search broadly and perform
     * tighter bounded tracking.
     */
    @JsonProperty("mode")
    public Optional<FieldOfViewMode> getMode() {
        return mode;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof FieldOfView && equalTo((FieldOfView) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(FieldOfView other) {
        return fovId.equals(other.fovId)
                && mountId.equals(other.mountId)
                && projectedFrustum.equals(other.projectedFrustum)
                && projectedCenterRay.equals(other.projectedCenterRay)
                && centerRayPose.equals(other.centerRayPose)
                && horizontalFov.equals(other.horizontalFov)
                && verticalFov.equals(other.verticalFov)
                && range.equals(other.range)
                && mode.equals(other.mode);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.fovId,
                this.mountId,
                this.projectedFrustum,
                this.projectedCenterRay,
                this.centerRayPose,
                this.horizontalFov,
                this.verticalFov,
                this.range,
                this.mode);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<Integer> fovId = Optional.empty();

        private Optional<String> mountId = Optional.empty();

        private Optional<ProjectedFrustum> projectedFrustum = Optional.empty();

        private Optional<Position> projectedCenterRay = Optional.empty();

        private Optional<Pose> centerRayPose = Optional.empty();

        private Optional<Float> horizontalFov = Optional.empty();

        private Optional<Float> verticalFov = Optional.empty();

        private Optional<Float> range = Optional.empty();

        private Optional<FieldOfViewMode> mode = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(FieldOfView other) {
            fovId(other.getFovId());
            mountId(other.getMountId());
            projectedFrustum(other.getProjectedFrustum());
            projectedCenterRay(other.getProjectedCenterRay());
            centerRayPose(other.getCenterRayPose());
            horizontalFov(other.getHorizontalFov());
            verticalFov(other.getVerticalFov());
            range(other.getRange());
            mode(other.getMode());
            return this;
        }

        /**
         * <p>The Id for one instance of a FieldOfView, persisted across multiple updates to provide continuity during
         * smoothing. This is relevant for sensors where the dwell schedule is on the order of
         * milliseconds, making multiple FOVs a requirement for proper display of search beams.</p>
         */
        @JsonSetter(value = "fovId", nulls = Nulls.SKIP)
        public Builder fovId(Optional<Integer> fovId) {
            this.fovId = fovId;
            return this;
        }

        public Builder fovId(Integer fovId) {
            this.fovId = Optional.ofNullable(fovId);
            return this;
        }

        /**
         * <p>The Id of the mount the sensor is on.</p>
         */
        @JsonSetter(value = "mountId", nulls = Nulls.SKIP)
        public Builder mountId(Optional<String> mountId) {
            this.mountId = mountId;
            return this;
        }

        public Builder mountId(String mountId) {
            this.mountId = Optional.ofNullable(mountId);
            return this;
        }

        /**
         * <p>The field of view the sensor projected onto the ground.</p>
         */
        @JsonSetter(value = "projectedFrustum", nulls = Nulls.SKIP)
        public Builder projectedFrustum(Optional<ProjectedFrustum> projectedFrustum) {
            this.projectedFrustum = projectedFrustum;
            return this;
        }

        public Builder projectedFrustum(ProjectedFrustum projectedFrustum) {
            this.projectedFrustum = Optional.ofNullable(projectedFrustum);
            return this;
        }

        /**
         * <p>Center ray of the frustum projected onto the ground.</p>
         */
        @JsonSetter(value = "projectedCenterRay", nulls = Nulls.SKIP)
        public Builder projectedCenterRay(Optional<Position> projectedCenterRay) {
            this.projectedCenterRay = projectedCenterRay;
            return this;
        }

        public Builder projectedCenterRay(Position projectedCenterRay) {
            this.projectedCenterRay = Optional.ofNullable(projectedCenterRay);
            return this;
        }

        /**
         * <p>The origin and direction of the center ray for this sensor relative to the ENU frame. A ray which is aligned with
         * the positive X axis in the sensor frame will be transformed into the ray along the sensor direction in the ENU
         * frame when transformed by the quaternion contained in this pose.</p>
         */
        @JsonSetter(value = "centerRayPose", nulls = Nulls.SKIP)
        public Builder centerRayPose(Optional<Pose> centerRayPose) {
            this.centerRayPose = centerRayPose;
            return this;
        }

        public Builder centerRayPose(Pose centerRayPose) {
            this.centerRayPose = Optional.ofNullable(centerRayPose);
            return this;
        }

        /**
         * <p>Horizontal field of view in radians.</p>
         */
        @JsonSetter(value = "horizontalFov", nulls = Nulls.SKIP)
        public Builder horizontalFov(Optional<Float> horizontalFov) {
            this.horizontalFov = horizontalFov;
            return this;
        }

        public Builder horizontalFov(Float horizontalFov) {
            this.horizontalFov = Optional.ofNullable(horizontalFov);
            return this;
        }

        /**
         * <p>Vertical field of view in radians.</p>
         */
        @JsonSetter(value = "verticalFov", nulls = Nulls.SKIP)
        public Builder verticalFov(Optional<Float> verticalFov) {
            this.verticalFov = verticalFov;
            return this;
        }

        public Builder verticalFov(Float verticalFov) {
            this.verticalFov = Optional.ofNullable(verticalFov);
            return this;
        }

        /**
         * <p>Sensor range in meters.</p>
         */
        @JsonSetter(value = "range", nulls = Nulls.SKIP)
        public Builder range(Optional<Float> range) {
            this.range = range;
            return this;
        }

        public Builder range(Float range) {
            this.range = Optional.ofNullable(range);
            return this;
        }

        /**
         * <p>The mode that this sensor is currently in, used to display for context in the UI. Some sensors can emit multiple
         * sensor field of views with different modes, for example a radar can simultaneously search broadly and perform
         * tighter bounded tracking.</p>
         */
        @JsonSetter(value = "mode", nulls = Nulls.SKIP)
        public Builder mode(Optional<FieldOfViewMode> mode) {
            this.mode = mode;
            return this;
        }

        public Builder mode(FieldOfViewMode mode) {
            this.mode = Optional.ofNullable(mode);
            return this;
        }

        public FieldOfView build() {
            return new FieldOfView(
                    fovId,
                    mountId,
                    projectedFrustum,
                    projectedCenterRay,
                    centerRayPose,
                    horizontalFov,
                    verticalFov,
                    range,
                    mode,
                    additionalProperties);
        }
    }
}
